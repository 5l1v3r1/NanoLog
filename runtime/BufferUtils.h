/* Copyright (c) 2016 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <ctime>
#include <fstream>

#include <assert.h>

#include "Cycles.h"
#include "Packer.h"

#ifndef BUFFERUTILS_H
#define BUFFERUTILS_H

/**
 * BufferUtils provides a collection of data structures and functions to 
 * manage the metadata in the various buffers of the FastLogger System.
 * It is implemented as a namespace to allow easy and low-latency
 * (i.e. inlined) access to C++ code generated by the Python preprocessor.
 *
 * Note that BufferUtils only manages the metadata and hence the rough
 * layout of the data. How argument data is recorded/packed in the buffers
 * is managed by the Python preprocessor in the form of generated C++ code.
 */

namespace BufferUtils {

    // Determines the byte size of all buffers in the FastLogger System, which
    // includes the thread local staging buffers and (de)compression buffers
    static const uint32_t BUFFER_SIZE = 1<<26; // 64MB

    /**
     * Header to a record entry within the Staging Buffer. After this header
     * comes the uncompressed arguments related to the original log message.
     */
    struct RecordEntry {
        // Stores the format ID assigned to the log message by the preprocessor
        // component that uniquely identifies the original format string and
        // its code location. A value of 0 indicates an invalid entry.
        uint32_t fmtId;

        // Stores the rdtsc() value at the time of the record invocation
        uint64_t timestamp;

        // Number of bytes for this header and the various arguments after it
        uint32_t entrySize;

        // Number of bytes that should be allocated for the Packer Nibbles
        // TODO(syang0) remove this when you implement the better packer
        uint8_t argMetaBytes;

        // After this header, comes the uncompressed arguments
        char argData[];
    };

    /**
     * 2-bit enum that differentiates entries in the compressed log
     */
    enum EntryType : uint8_t {
        INVALID = 0,
        LOG_MSG = 1,
        CHECKPOINT = 2,
        END_OF_FILE = 3
    };
    
    /**
     * Compressed version of the RecordEntry that goes in the output
     * buffer/file. Note the fmtId and timestamp fields are not longer
     * present since they will be pack()-ed after this header.
     */
    struct CompressedMetadata {
        // Identifies the entry type to detect validity
        uint8_t entryType:2;

        // Number of bytes + 1 in the compressed FmtId after this entry.
        // This value + 1 is to be passed into unpack()
        uint8_t additionalFmtIdBytes:2;

        // Number of bytes + 1 in the compressed timestamp. This value + 1
        // is to be passed into unpack()
        uint8_t additionalTimestampBytes:3;
        
        // After this is the packed fmtId, packed timestamp, nibbles, and more
        // packed arguments.
    } __attribute__((packed));

    /**
     * Checkpoint data-structure to be inserted in the compressed log
     * periodically that helps synchronize rtdsc() times with wall time.
     */
    struct Checkpoint : CompressedMetadata {
        uint64_t rdtsc;
        time_t unixTime;
        double cyclesPerSecond;
    } __attribute__((packed));

    /**
     * The decompressed version of original record entry. At this point, the
     * sizes/bytes arguments are no longer needed since they're encoded in
     * the buffer itself and within the nibbles provided by the packer.
     */
    struct DecompressedMetadata {
        // Stores the format ID assigned to the log message by the preprocessor
        uint32_t fmtId;

        // Stores the rdtsc() value at the time of the record invocation
        uint64_t timestamp;
    };

    /**
     * Copies a primitive to a character array and bumps the array pointer.
     * This is used by the injected record code to save primitives to the
     * staging buffer.
     *
     * \param buffer - Buffer to copy primitive to
     * \param val - value of primitive
     */
    template<typename T>
    static inline void
    recordPrimitive(char* &buffer, T val) {
        *(reinterpret_cast<T*>(buffer)) = val;
        buffer += sizeof(T);
    }

    /**
     * Convenience function fill out a RecordEntry in the staging buffer. This
     * is used by the injected record code.
     *
     * \param re - RecordEntry gotten from FastLogger::reserveAlloc()
     * \param fmtId - format id assigned to the log message by the preprocessor
     * \param maxArgSize - number of bytes the arguments take up in the record
     * \param compressedArgsMetaBytes - number of bytes that will need to be
     *                                  allocated in the compressed log to store
     *                                  the pack() nibbles.
     */
    inline void
    recordMetadata(RecordEntry* re, uint32_t fmtId, size_t maxArgSize,
                        uint8_t compressedArgsMetaBytes) {
        re->fmtId = fmtId;
        re->timestamp = PerfUtils::Cycles::rdtsc();
        re->entrySize = static_cast<uint32_t>(maxArgSize + sizeof(RecordEntry));
        re->argMetaBytes = compressedArgsMetaBytes;
    }

    /**
     * Convenience function to extract the information from a RecordEntry
     * in the staging buffer and compress it into the output buffer.
     *
     * This packs the metadata as follows:
     *      1 Byte of CompressedMetadata
     *      1-4 bytes of formatId
     *      1-8 bytes of rtdsc()
     * 
     * \param re - RecordEntry to compress
     * \param out - output buffer to compress to
     * \param lastTimestamp - the last timestamp that was compressed into the
     *                        output buffer. This is used to pack the timestamp
     *                        more compactly.
     * \param lastFmtId     - the last format id that was compressed into the
     *                        output buffer. This is used to pack the format id
     *                        more compactly
     */
    inline void
    compressMetadata(RecordEntry *re, char** out, uint64_t lastTimestamp,
                        uint32_t lastFmtId) {
        CompressedMetadata *mo = reinterpret_cast<CompressedMetadata*>(*out);
        *out += sizeof(CompressedMetadata);

        mo->entryType = EntryType::LOG_MSG;

        // Bitmask is needed to prevent -Wconversion warnings
        mo->additionalFmtIdBytes = 0x03 & static_cast<uint8_t>(
                BufferUtils::pack(out, re->fmtId - lastFmtId) - 1);
        mo->additionalTimestampBytes = 0x07 & static_cast<uint8_t>(
                    BufferUtils::pack(out, re->timestamp - lastTimestamp) - 1);
    }

    /**
     * Read in and decompress the metadata from a compress log. It uses some
     * data from the log message that came before it to perform the
     * decompression. (If first, pass in 0).
     *
     * \param in - file stream to read from
     * \param lastFmtId - last format id that was decompressed
     * \param lastTimestamp - last time stamp that was decompressed
     * \return - the decompressed metadata
     */
    inline DecompressedMetadata
    decompressMetadata(std::ifstream &in, uint32_t lastFmtId, 
            uint64_t lastTimestamp)
    {
        DecompressedMetadata dm;
        CompressedMetadata cm;
        in.read(reinterpret_cast<char*>(&cm), sizeof(CompressedMetadata));
        assert(cm.entryType == EntryType::LOG_MSG);
        
        dm.fmtId =
            BufferUtils::unpack<uint32_t>(in,
                        static_cast<uint8_t>(cm.additionalFmtIdBytes + 1));
        dm.timestamp =
            BufferUtils::unpack<uint64_t>(in,
                        static_cast<uint8_t>(cm.additionalTimestampBytes + 1));

        dm.fmtId += lastFmtId;
        dm.timestamp += lastTimestamp;

        return dm;
    }

    /**
     * Peek in an input file stream to see if there is potentially a valid
     * entry that can be read
     *
     * \param in - file stream to read from
     *
     * \return - an EntryType specifying what it is.
     */
    inline EntryType
    peekEntryType(std::ifstream &in) {
        // CompressedMetadata only takes a byte, so we can peek it and determine
        // the entry type.
        static_assert(sizeof(CompressedMetadata) == 1,
                "CompressedMetadata should only be 1 byte "
                "so we can peek() it at decompression");

        int type = in.peek();
        if (type == EOF)
            return EntryType::END_OF_FILE;
        if (type < 0 || type > 255)
            return EntryType::INVALID;

        CompressedMetadata *cm = reinterpret_cast<CompressedMetadata*>(&type);
        return EntryType(cm->entryType);
    }

    /**
     * Insert a checkpoint into an output buffer. This is a relatively
     * expensive operation in terms of storage, so it should be used
     * sparingly.
     *
     * \param out - output array to insert the checkpoint into
     * \param outLimit - end of the output array
     *
     * \return - true if operation succeed, false if there's not enough space
     */
    static inline bool
    insertCheckpoint(char** out, char *outLimit) {
        if (static_cast<uint64_t>(outLimit - *out) < sizeof(Checkpoint))
            return false;

        Checkpoint *ck = reinterpret_cast<Checkpoint*>(*out);
        *out += sizeof(Checkpoint);
        
        ck->entryType = EntryType::CHECKPOINT;
        ck->rdtsc = PerfUtils::Cycles::rdtsc();
        ck->unixTime = std::time(nullptr);
        ck->cyclesPerSecond = PerfUtils::Cycles::getCyclesPerSec();

        return true;
    }

    /**
     * Extracts a checkpoint from the log.
     *
     * \param in - compressed log to read from
     * \return - the extracted Checkpoint
     */
    inline Checkpoint
    readCheckpoint(std::ifstream &in) {
        Checkpoint cp;
        in.read(reinterpret_cast<char*>(&cp), sizeof(Checkpoint));
        return cp;
    }

}; /* Buffer Utils */

#endif /* BUFFERUTILS_H */

