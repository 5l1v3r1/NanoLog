/* Copyright (c) 2016-2017 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <ctime>

#include <assert.h>
#include <stdio.h>

#include "Cycles.h"
#include "Packer.h"
#include "Util.h"

#ifndef BUFFERUTILS_H
#define BUFFERUTILS_H

/**
 * BufferUtils provides a collection of data structures and functions to
 * manage the metadata in the various buffers of the NanoLog System.
 * It is implemented as a namespace to allow easy and low-latency
 * (i.e. inlined) access to C++ code generated by the Python preprocessor.
 *
 * Note that BufferUtils only manages the metadata and hence the rough
 * layout of the data. How argument data is recorded/packed in the buffers
 * is managed by the Python preprocessor in the form of generated C++ code.
 */

namespace BufferUtils {

    /**
     * Marks the beginning of a log entry within the StagingBuffer waiting
     * for compression. Every instance of this header in the StagingBuffer
     * corresponds to a user invocation of the log function in the NanoLog
     * system and thus every field is uncompressed to lower the compute time
     * for that invocation.
     */
    struct UncompressedLogEntry {
        // Uniquely identifies a log message by its format string and file
        // location, assigned at compile time by the preprocessor.
        uint32_t fmtId;

        // Number of bytes for this header and the various arguments after it
        uint32_t entrySize;

        // Stores the rdtsc() value at the time of the log function invocation
        uint64_t timestamp;

        // After this header are the uncompressed arguments required by
        // the original format string
        char argData[];
    };

    /**
     * 2-bit enum that differentiates entries in the compressed log. These
     * two bits **MUST** be at the beginning of each entry in the log
     * to facilitate decoding.
     */
    enum EntryType : uint8_t {
        // Marks an invalid entry in the compressed log. This value is
        // deliberately 0 since \0's are used to pad the output to 512B
        // in the final output.
        INVALID = 0,

        // Indicates a CompressedRecordEntry that can be decompressed
        LOG_MSG = 1,

        // Indicates a struct CheckPoint
        CHECKPOINT = 2,

        // Indicates that the next LOG_MSG's which come after this input are
        // from a different buffer.
        BUFFER_CHANGE = 3
    };

    /**
     * Marker in the compressed log that indicates to which StagingBuffer/Thread
     * the next contiguous chunk of LOG_MSG's belong to (before the next
     * BufferChange marker).
     */
    struct BufferChange {
        // Byte representation of EntryType::BUFFER_CHANGE
        uint8_t entryType:2;

        // Indicates that the BufferChange also corresponds with a complete
        // pass through all the StagingBuffer's at runtime. This information can
        // be used to determine the maximal temporal reordering that can occur
        // in the linear compressed log.
        uint8_t wrapAround:1;

        // A value of 1 indicates the next 4 bits are a threadId, else
        // the next 4 bits are the 4-bit result of a pack() operation.
        uint8_t isShort:1;

        // Value is either a 4-bit threadId or a Pack() result used to compact
        // the thread id that comes after this header.
        uint8_t threadIdOrPackNibble:4;

        // Optimization that hints that the next BufferChange structure is at
        // least this many bytes later in the buffer. After this many bytes,
        // one may find a BufferChange structure, other entries before the next
        // BufferChange, or no BufferChange at all (if it's towards the end of
        // the file).
        uint32_t minDistanceToNextBufferChange;

        // Returns the maximum size the BufferChange structure can be with
        // the Pack()-ed arguments.
        static int maxSize() {
            return sizeof(BufferChange) + sizeof(uint32_t);
        }
    } __attribute__((packed));

    /**
     * Insert a BufferChange marker in the output which associates the log
     * messages that come after it in the output with a particular runtime
     * StagingBuffer.
     *
     * \param bufferId
     *      Id of the StagingBuffer to tag the marker with
     *
     * \param wrapAround
     *      Indicates whether this marker also corresponds with a complete pass
     *      through the runtime StagingBuffer's
     *
     * \param[in/out] output
     *      Buffer to insert the BufferChange marker into and bump the pointer
     *
     * \param endOfOut
     *      Marks the end of output (used to compute free space)
     *
     * \param hintNext
     *      A uint32_t pointer that can be used to hint at the minimum number
     *      of bytes between this BufferChange and the next. This parameter is
     *      exposed as a pointer to allow setting the value after the
     *      BufferChange has been encoded.
     *
     * \return
     *      Indicates whether the operation was successful (true) or has failed
     *      due to insufficient space (false).
     */
    inline bool
    encodeBufferChange(uint32_t bufferId, bool wrapAround, char** output,
                            const char* endOfOut, uint32_t **hintNext=NULL)
    {
        if (sizeof(BufferChange) + sizeof(bufferId) >
                static_cast<size_t>((endOfOut - *output)))
            return false;

        BufferChange *tc = reinterpret_cast<BufferChange*>(*output);
        tc->wrapAround = wrapAround;
        tc->entryType = EntryType::BUFFER_CHANGE;
        tc->minDistanceToNextBufferChange = 0;
        *output += sizeof(BufferChange);

        if (hintNext)
            *hintNext = &tc->minDistanceToNextBufferChange;

        if (bufferId < (1<<4)) {
            tc->isShort = true;
            tc->threadIdOrPackNibble = 0x0F & bufferId;
        } else {
            tc->isShort = false;
            tc->threadIdOrPackNibble = 0x0F & pack(output, bufferId);
        }

        return true;
    }

    /**
     * Read back the bufferId embedded in a BufferChange marker within the
     * character array and bump the array pointer to "consume" the data.
     * Note, it is the responsibility of the caller to ensure that the
     * array contains a BufferChange marker.
     *
     * \param in
     *      Input character buffer to interpret the BufferChange marker
     * \param[out] wrapAround
     *      An optional bool pointer that if set, indicates whether the runtime
     *      encoded a wrapAround occurrence whereby the log compressor made
     *      a complete pass through all the StagingBuffers.
     * \param[out] hintNextBufferChange
     *      An optional uint32_t pointer that if set, indicates the minimum
     *      byte distance to the next BufferChange structure.
     * \return
     *      The buffer id associated with the marker.
     */
    inline uint32_t
    decodeBufferChange(const char **in, bool *wrapAround=NULL,
                        uint32_t *hintNextBufferChange=NULL) {
        BufferChange tc;
        memcpy(&tc, (*in), sizeof(BufferChange));
        (*in) += sizeof(BufferChange);
        assert(tc.entryType == EntryType::BUFFER_CHANGE);

        if (wrapAround)
            *wrapAround = tc.wrapAround;

        if (hintNextBufferChange)
            *hintNextBufferChange = tc.minDistanceToNextBufferChange;

        if (tc.isShort)
            return tc.threadIdOrPackNibble;

        return unpack<uint32_t>(in, tc.threadIdOrPackNibble);
    }

    /**
     * Marks the beginning of a compressed log message. After this comes
     * the compressed arguments. The layout in the compressed file is as folows:
     *      - (1 byte) CompresedRecordEntry (this)
     *      - (1-4 bytes) pack()-ed FormatId
     *      - (1-8 bytes) pack()-ed rtsc() timestmap
     *      - (n bytes) Packer Nibbles
     *      - (m bytes) pack()-ed arguments
     *      - (o bytes) uncompressed strings
     */
    struct CompressedRecordEntry {
        // Byte representation of an EntryType::LOG_MSG to identify this as
        // a CompressedRecordEntry.
        uint8_t entryType:2;

        // TODO(syang0) this is an abstraction failure.
        // Value returned by pack(formatId), subtracted by 1 to save space.
        // i.e. if pack() returned 2 this value is 1.
        uint8_t additionalFmtIdBytes:2;

        // Value returned by pack(timestamp)
        uint8_t additionalTimestampBytes:4;
    } __attribute__((packed));

    /**
     * Synchronization data structure that correlates the machine's rdtsc()
     * with a wall time.
     */
    struct Checkpoint {
        // Byte representation of an EntryType::CHECKPOINT
        uint64_t entryType:2;

        // rdtsc() time that corresponds with the unixTime below
        uint64_t rdtsc:62;

        // std::time() that corresponds with the rdtsc() above
        time_t unixTime;

        // Conversion factor between cycles returned by rdtsc() and 1 second
        double cyclesPerSecond;
    } __attribute__((packed));

    //TODO(syang0) move implementation into preprocessor
    /**
     * The decompressed version of original record entry. At this point, the
     * sizes/bytes arguments are no longer needed since they're encoded in
     * the buffer itself and within the nibbles provided by the packer.
     */
    struct DecompressedMetadata {
        // Stores the format ID assigned to the log message by the preprocessor
        uint32_t fmtId;

        // Stores the rdtsc() value at the time of the record invocation
        uint64_t timestamp;
    };

    /**
     * Copies a primitive to a character array and bumps the array pointer.
     * This is used by the injected record code to save primitives to the
     * staging buffer.
     *
     * \param buffer
     *      Buffer to copy primitive to
     * \param val
     *      value of primitive
     */
    template<typename T>
    static inline void
    recordPrimitive(char* &buffer, T val) {
        *(reinterpret_cast<T*>(buffer)) = val;
        buffer += sizeof(T);
    }

    /**
     * Convenience function to extract the information from a RecordEntry
     * in the staging buffer and compress it into the output buffer.
     *
     * This packs the metadata as follows:
     *      1 Byte of CompressedMetadata
     *      1-4 bytes of formatId
     *      1-8 bytes of rtdsc()
     *
     * \param re
     *          RecordEntry to compress
     * \param[in/out] out
     *          Output byte buffer to compress the entry into
     * \param lastTimestamp
     *          The last timestamp that was compressed into the output buffer.
     *          This is used to pack the timestamp more compactly.
     *
     * \return
     *          Number of bytes written to out
     */
    inline size_t
    compressMetadata(UncompressedLogEntry *re, char** out,
                        uint64_t lastTimestamp) {
        CompressedRecordEntry *mo = reinterpret_cast<CompressedRecordEntry*>(
                                                                          *out);
        *out += sizeof(CompressedRecordEntry);

        mo->entryType = EntryType::LOG_MSG;

        // Bitmask is needed to prevent -Wconversion warnings
        mo->additionalFmtIdBytes = 0x03 & static_cast<uint8_t>(
                BufferUtils::pack(out, re->fmtId) - 1);
        mo->additionalTimestampBytes = 0x0F & static_cast<uint8_t>(
                    BufferUtils::pack(out, static_cast<int64_t>(
                                            re->timestamp - lastTimestamp)));

        return sizeof(CompressedRecordEntry)
                    + mo->additionalFmtIdBytes + 1
                    + (0x7 & mo->additionalTimestampBytes);
    }

    //TODO(syang0) abstract into the generated code
    /**
     * Read in and decompress the metadata from a UncompressedLogEntry.
     *
     * \param in
     *      character array to read in from
     * \param lastTimestamp
     *      last timestamp that was decompressed (abstraction leakage)
     *
     * \return
     *              the decompressed metadata
     */
    inline DecompressedMetadata
    decompressMetadata(const char **in, uint64_t lastTimestamp)
    {
        DecompressedMetadata dm;
        CompressedRecordEntry cm;
        memcpy(&cm, (*in), sizeof(CompressedRecordEntry));
        (*in) += sizeof(CompressedRecordEntry);
        assert(cm.entryType == EntryType::LOG_MSG);

        dm.fmtId =
            BufferUtils::unpack<uint32_t>(in,
                        static_cast<uint8_t>(cm.additionalFmtIdBytes + 1));
        dm.timestamp =
            BufferUtils::unpack<int64_t>(in,
                        static_cast<uint8_t>(cm.additionalTimestampBytes));

        dm.timestamp += lastTimestamp;
        return dm;
    }

    /**
     * Peek into a data array and identify the next entry embedded in the
     * compressed log (if there is one) and read it back.
     *
     * \param in
     *      Character array to peek into
     * \return
     *      An EntryType specifying what comes next
     */
    inline EntryType
    peekEntryType(char *in) {
        int type = (uint8_t)(*in);
        if (type == EOF || type < 0 || type > 255)
            return EntryType::INVALID;

        // TODO(syang0) breaks more abstractions
        static_assert(sizeof(CompressedRecordEntry) == 1,
                "CompressedMetadata should only be 1 byte "
                "so we can peek() it at decompression");

        CompressedRecordEntry *cm = reinterpret_cast<CompressedRecordEntry*>(&type);
        return EntryType(cm->entryType);
    }

    /**
     * Peek into the next byte in the file and identify the next entry embedded
     * in the compressed log (if there is one) and read it back.
     *
     * \param fd
     *      File descriptor to peek into
     * \return
     *      EntryType corresponding to the next entry in the compressed log
     */
    inline EntryType
    peekEntryType(FILE *fd) {
        int type = fgetc(fd);
        ungetc(type, fd);

        if (type == EOF || type < 0 || type > 255)
            return EntryType::INVALID;

        static_assert(sizeof(CompressedRecordEntry) == 1,
                "CompressedMetadata should only be 1 byte "
                "so we can peek() it at decompression");

        CompressedRecordEntry *cm = reinterpret_cast<CompressedRecordEntry*>(&type);
        return EntryType(cm->entryType);
    }

    /**
     * Insert a checkpoint into an output buffer. This is a relatively
     * expensive operation in terms of storage, so it should be used
     * sparingly.
     *
     * \param out[in/out]
     *              Output array to insert the checkpoint into
     * \param outLimit
     *              Pointer to the end of out (i.e. first invalid byte to
     *              write to)
     *
     * \return
     *              True if operation succeed, false if there's not enough space
     */
    static inline bool
    insertCheckpoint(char** out, char *outLimit) {
        if (static_cast<uint64_t>(outLimit - *out) < sizeof(Checkpoint))
            return false;

        Checkpoint *ck = reinterpret_cast<Checkpoint*>(*out);
        *out += sizeof(Checkpoint);

        ck->entryType = EntryType::CHECKPOINT;
        ck->rdtsc = 0x3FFFFFFFFFFFFFFF & PerfUtils::Cycles::rdtsc();
        ck->unixTime = std::time(nullptr);
        ck->cyclesPerSecond = PerfUtils::Cycles::getCyclesPerSec();

        return true;
    }

    /**
     * Extracts a checkpoint from a character array and bumps the pointer to
     * "consume" the data.
     *
     * \param[in/out] in
     *      Character data stream to read from
     * \return
     *      The extracted Checkpoint
     */
    inline Checkpoint
    readCheckpoint(char **in) {
        Checkpoint cp;
        memcpy(&cp, (*in), sizeof(Checkpoint));
        (*in) += sizeof(Checkpoint);
        return cp;
    }

    /**
     * Extracts a checkpoint from a character array from a file descriptor.
     *
     * \param[out] cp
     *      Checkpoint structure to read the data into
     * \param fd
     *      Stream to read checkpoint from
     *
     * \return
     *      Whether the operation succeeded or failed due to lack of
     *      space/malformed log
     */
    inline bool
    readCheckpoint(Checkpoint &cp, FILE *fd) {
        cp.entryType = EntryType::INVALID;
        long numRead = fread(&cp, sizeof(Checkpoint), 1UL, fd);

        if (!numRead)
            return false;

        assert(cp.entryType == EntryType::CHECKPOINT);
        return true;
    }

    /**
     * Safer implementation of strlen that allows for an upper bound
     *
     * \param str
     *          String to check
     * \param maxLen
     *          Maximum length to check
     */
    static inline size_t
    strnlen(const char* str, size_t maxLen=-1) {
        size_t length = 0;
        while (*str != '\0' && length < maxLen) {
            ++str;
            ++length;
        }

        return length;
    }

    static inline size_t
    strnlen(const wchar_t* str, size_t maxLen=-1) {
        size_t length = 0;
        while (*str != '\0' && length < maxLen) {
            ++str;
            ++length;
        }

        return length;
    }

}; /* Buffer Utils */

#endif /* BUFFERUTILS_H */

