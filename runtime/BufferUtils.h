/* Copyright (c) 2016 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <ctime>
#include <fstream>

#include <assert.h>

#include "Cycles.h"
#include "Packer.h"
#include "Util.h"

#ifndef BUFFERUTILS_H
#define BUFFERUTILS_H

/**
 * BufferUtils provides a collection of data structures and functions to
 * manage the metadata in the various buffers of the FastLogger System.
 * It is implemented as a namespace to allow easy and low-latency
 * (i.e. inlined) access to C++ code generated by the Python preprocessor.
 *
 * Note that BufferUtils only manages the metadata and hence the rough
 * layout of the data. How argument data is recorded/packed in the buffers
 * is managed by the Python preprocessor in the form of generated C++ code.
 */

namespace BufferUtils {

    /**
     * Marks the beginning of a log entry within the StagingBuffer waiting
     * for compression. Every instance of this header in the StagingBuffer
     * corresponds to a user invocation of the log function in the FastLogger
     * system and thus every field is uncompressed to lower the compute time
     * for that invocation.
     */
    struct UncompressedLogEntry {
        // Uniquely identifies a log message by its format string and file
        // location, assigned at compile time by the preprocessor.
        uint32_t fmtId;

        // Stores the rdtsc() value at the time of the log function invocation
        uint64_t timestamp;

        // Number of bytes for this header and the various arguments after it
        uint32_t entrySize;

        // Number of bytes that should be allocated for the Packer Nibbles
        // TODO(syang0) remove this when you implement the better packer
        uint8_t argMetaBytes;

        // After this header are the uncompressed arguments required by
        // the original format string
        char argData[];
    };

    /**
     * 2-bit enum that differentiates entries in the compressed log. These
     * two bits **MUST** be at the beginning of each entry in the log
     * to facilitate decoding.
     */
    enum EntryType : uint8_t {
        // Marks an invalid entry in the compressed log. This value is
        // deliberately 0 since \0's are used to pad the output to 512B
        // in the final output.
        INVALID = 0,

        // Indicates a CompressedRecordEntry that can be decompressed
        LOG_MSG = 1,

        // Indicates a struct CheckPoint
        CHECKPOINT = 2,

        // Indicates the end of the file stream/buffer
        END_OF_FILE
    };

    /**
     * Marks the beginning of a compressed log message. After this comes
     * the compressed arguments. The layout in the compressed file is as folows:
     *      - (1 byte) CompresedRecordEntry (this)
     *      - (1-4 bytes) pack()-ed FormatId
     *      - (1-8 bytes) pack()-ed rtsc() timestmap
     *      - (n bytes) Packer Nibbles
     *      - (m bytes) pack()-ed arguments
     *      - (o bytes) uncompressed strings
     */
    struct CompressedRecordEntry {
        // Byte representation of an EntryType::LOG_MSG to identify this as
        // a CompressedRecordEntry.
        uint8_t entryType:2;

        //TODO(syang0) abstraction failure
        // Value returned by pack(formatId), subtracted by 1.
        // i.e. if pack() returned 2 this value is 1.
        uint8_t additionalFmtIdBytes:2;

        // Value returned by pack(timestamp), subtracted by 1.
        uint8_t additionalTimestampBytes:3;
    } __attribute__((packed));

    /**
     * Synchronization data structure that correlates the machine's rdtsc()
     * with a wall time.
     */
    struct Checkpoint {
        // Byte representation of an EntryType::CHECKPOINT
        uint64_t entryType:2;

        // rdtsc() time that corresponds with the unixTime below
        uint64_t rdtsc:62;

        // std::time() that corresponds with the rdtsc() above
        time_t unixTime;

        // Conversion factor between cycles returned by rdtsc() and 1 second
        double cyclesPerSecond;
    } __attribute__((packed));

    //TODO(syang0) move implementation into preprocessor
    /**
     * The decompressed version of original record entry. At this point, the
     * sizes/bytes arguments are no longer needed since they're encoded in
     * the buffer itself and within the nibbles provided by the packer.
     */
    struct DecompressedMetadata {
        // Stores the format ID assigned to the log message by the preprocessor
        uint32_t fmtId;

        // Stores the rdtsc() value at the time of the record invocation
        uint64_t timestamp;
    };

    /**
     * Copies a primitive to a character array and bumps the array pointer.
     * This is used by the injected record code to save primitives to the
     * staging buffer.
     *
     * \param buffer
     *      Buffer to copy primitive to
     * \param val
     *      value of primitive
     */
    template<typename T>
    static inline void
    recordPrimitive(char* &buffer, T val) {
        *(reinterpret_cast<T*>(buffer)) = val;
        buffer += sizeof(T);
    }

    /**
     * Convenience function to extract the information from a RecordEntry
     * in the staging buffer and compress it into the output buffer.
     *
     * This packs the metadata as follows:
     *      1 Byte of CompressedMetadata
     *      1-4 bytes of formatId
     *      1-8 bytes of rtdsc()
     *
     * \param re
     *          RecordEntry to compress
     * \param[in/out] out
     *          Output byte buffer to compress the entry into
     * \param lastTimestamp
     *          The last timestamp that was compressed into the output buffer.
     *          This is used to pack the timestamp more compactly.
     * \param lastFmtId
     *          The last format id that was compressed into the output buffer.
     *          This is used to pack the format id more compactly
     *
     * \return
     *          Number of bytes written to out
     */
    inline size_t
    compressMetadata(UncompressedLogEntry *re, char** out,
                        uint64_t lastTimestamp,  uint32_t lastFmtId) {
        CompressedRecordEntry *mo = reinterpret_cast<CompressedRecordEntry*>(
                                                                          *out);
        *out += sizeof(CompressedRecordEntry);

        mo->entryType = EntryType::LOG_MSG;

        // Bitmask is needed to prevent -Wconversion warnings
        mo->additionalFmtIdBytes = 0x03 & static_cast<uint8_t>(
                BufferUtils::pack(out, re->fmtId - lastFmtId) - 1);
        mo->additionalTimestampBytes = 0x07 & static_cast<uint8_t>(
                    BufferUtils::pack(out, re->timestamp - lastTimestamp) - 1);

        return sizeof(CompressedRecordEntry)
                    + mo->additionalFmtIdBytes + 1
                    + mo->additionalTimestampBytes + 1;
    }

    //TODO(syang0) abstract into the generated code
    /**
     * Read in and decompress the metadata from a UncompressedLogEntry.
     *
     * \param in
     *              File stream to read from
     * \param lastFmtId
     *              Last format id that was decompressed (abstraction leakage)
     * \param lastTimestamp
     *              Last time stamp that was decompressed (abstraction leakage)
     *
     * \return
     *              the decompressed metadata
     */
    inline DecompressedMetadata
    decompressMetadata(std::ifstream &in, uint32_t lastFmtId,
            uint64_t lastTimestamp)
    {
        DecompressedMetadata dm;
        CompressedRecordEntry cm;
        in.read(reinterpret_cast<char*>(&cm), sizeof(CompressedRecordEntry));
        assert(cm.entryType == EntryType::LOG_MSG);

        dm.fmtId =
            BufferUtils::unpack<uint32_t>(in,
                        static_cast<uint8_t>(cm.additionalFmtIdBytes + 1));
        dm.timestamp =
            BufferUtils::unpack<uint64_t>(in,
                        static_cast<uint8_t>(cm.additionalTimestampBytes + 1));

        dm.fmtId += lastFmtId;
        dm.timestamp += lastTimestamp;

        return dm;
    }

    /**
     * Peek in an input file stream and identify the next entry (if there is
     * one) that can be read back.
     *
     * \param in
     *              File stream to peek into
     *
     * \return
     *              An EntryType specifying what comes next
     */
    inline EntryType
    peekEntryType(std::ifstream &in) {
        // CompressedMetadata only takes a byte, so we can peek it and determine
        // the entry type.
        static_assert(sizeof(CompressedRecordEntry) == 1,
                "CompressedMetadata should only be 1 byte "
                "so we can peek() it at decompression");

        int type = in.peek();
        if (type == EOF)
            return EntryType::END_OF_FILE;
        if (type < 0 || type > 255)
            return EntryType::INVALID;

        CompressedRecordEntry *cm = reinterpret_cast<CompressedRecordEntry*>(&type);
        return EntryType(cm->entryType);
    }

    /**
     * Insert a checkpoint into an output buffer. This is a relatively
     * expensive operation in terms of storage, so it should be used
     * sparingly.
     *
     * \param out[in/out]
     *              Output array to insert the checkpoint into
     * \param outLimit
     *              Pointer to the end of out (i.e. first invalid byte to
     *              write to)
     *
     * \return
     *              True if operation succeed, false if there's not enough space
     */
    static inline bool
    insertCheckpoint(char** out, char *outLimit) {
        if (static_cast<uint64_t>(outLimit - *out) < sizeof(Checkpoint))
            return false;

        Checkpoint *ck = reinterpret_cast<Checkpoint*>(*out);
        *out += sizeof(Checkpoint);

        ck->entryType = EntryType::CHECKPOINT;
        ck->rdtsc = 0x3FFFFFFFFFFFFFFF & PerfUtils::Cycles::rdtsc();
        ck->unixTime = std::time(nullptr);
        ck->cyclesPerSecond = PerfUtils::Cycles::getCyclesPerSec();

        return true;
    }

    /**
     * Extracts a checkpoint from a file stream
     *
     * \param in
     *          File stream to read from
     * \return
     *          The extracted Checkpoint
     */
    inline Checkpoint
    readCheckpoint(std::ifstream &in) {
        Checkpoint cp;
        in.read(reinterpret_cast<char*>(&cp), sizeof(Checkpoint));
        return cp;
    }

}; /* Buffer Utils */

#endif /* BUFFERUTILS_H */

