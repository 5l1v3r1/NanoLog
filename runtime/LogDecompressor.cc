/* Copyright (c) 2016-2017 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <cstdlib>
#include <fstream>
#include <vector>

#include <string.h>
#include <stdarg.h>

#include "BufferUtils.h"
#include "Cycles.h"

// File generated by the NanoLog preprocessor that contains all the
// compression and decompression functions.
#include "BufferStuffer.h"

using namespace BufferUtils;

#ifdef DEBUG_DECOMPRESSOR
#define DEBUG_PRINT(...) printf("DEBUG: " __VA_ARGS__)
#else
#define DEBUG_PRINT(...)
#endif

/**
 * Given a compressed NanoLog log file, decompress it and output it to an
 * outputFd.
 *
 * \param filename
 *      Compressed NanoLog log file to decompress
 * \param outputFd
 *      File Descriptor to fprintf the original log messages to
 * \param[optional] msgsToPrint
 *      Limit for how many log messages to print
 *
 * \return
 *      number of log encountered
 */
long
decompressLogsTo(const char *filename, FILE *outputFd, long msgsToPrint = 0)
{
    std::ifstream in(filename, std::ifstream::binary);
    if (!in.is_open()) {
        printf("Unable to open file: %s\r\n", filename);
        exit(-1);
    }
    fprintf(outputFd, "Opening file %s\r\n", filename);

    double cyclesPerSecond = PerfUtils::Cycles::getCyclesPerSec();
    Checkpoint cp;
    int linesPrinted = 0;
    bool bufferChanged = false;
    uint64_t lastTimestamp = 0;
    uint32_t hintNextBufferChange = 0;

    while (!in.eof()) {
        if (msgsToPrint > 0 && linesPrinted >= msgsToPrint)
            break;

        EntryType nextType = BufferUtils::peekEntryType(in);

        if (nextType == EntryType::LOG_MSG) {
            DecompressedMetadata dm =
                BufferUtils::decompressMetadata(in,
                                        (bufferChanged) ? 0 : lastTimestamp);
            bufferChanged = false;
            double timeDiff;
            if (dm.timestamp >= lastTimestamp)
                timeDiff = 1.0e9*PerfUtils::Cycles::toSeconds(
                                                dm.timestamp - lastTimestamp,
                                                cyclesPerSecond);
            else
                timeDiff = -1.0e9*PerfUtils::Cycles::toSeconds(
                                                lastTimestamp - dm.timestamp,
                                                cyclesPerSecond);
            if (linesPrinted == 0)
                timeDiff = 0;

           fprintf(outputFd, "%4d) +%12.2lf ns: ", linesPrinted, timeDiff);
            GeneratedFunctions::decompressAndPrintFnArray[dm.fmtId](
                                                            in, outputFd, NULL);
            lastTimestamp = dm.timestamp;
            ++linesPrinted;
        } else if (nextType == EntryType::CHECKPOINT) {
            cp = BufferUtils::readCheckpoint(in);
            cyclesPerSecond = cp.cyclesPerSecond;
            DEBUG_PRINT("DEBUG: Found Checkpoint\r\n");
        } else if (nextType == EntryType::INVALID) {
            // Consume pad bytes
            while(in.peek() == 0 && in.good())
                in.get();

            if (in.eof())
                break;
        } else {
            uint32_t currentPos = static_cast<uint32_t>(in.tellg());
            assert(currentPos >= hintNextBufferChange);
            uint32_t next;

            bufferChanged = true;
            bool wrapAround = false;

#ifndef DEBUG_DECOMPRESSOR
            BufferUtils::decodeBufferChange(in, &wrapAround, &next);
            if (hintNextBufferChange > 0) {}; // get rid of unused warnings.
#else
            uint32_t currentBufferId = BufferUtils::decodeBufferChange(
                        in, &wrapAround, &next);
            DEBUG_PRINT("Found buffer change at %ld to %d with wrapAround=%d and "
                    "next being %u bytes away.\r\n", (long)(in.tellg()),
                    currentBufferId, wrapAround, next);
#endif
            hintNextBufferChange = next + currentPos;
        }
    }

    fprintf(outputFd, "\r\n\r\nDecompression Complete after printing %d "
            "log messages\r\n", linesPrinted);

    return linesPrinted;
}

/**
 * Find all the original NANO_LOG format strings in the user sources that
 * statically contain the searchString and print them out in the format
 * "id   | filename | line | format string"
 *
 * \param searchString
 *      Static string to search for in the format strings
 */
void
printLogMetadataContainingSubstring(std::string searchString)
{
    std::vector<size_t> matchingLogIds;

    for (size_t i = 0; i < GeneratedFunctions::numLogIds; ++i) {
        const char *fmtMsg = GeneratedFunctions::logId2Metadata[i].fmtString;
        if (strstr(fmtMsg, searchString.c_str()))
            matchingLogIds.push_back(i);
    }

    printf("%4s | %-20s | %-4s | %s\r\n", "id", "filename", "line",
                                                            "format string");
    for (auto id : matchingLogIds) {
        GeneratedFunctions::LogMetadata lm = GeneratedFunctions::logId2Metadata[id];
        printf("%4lu | %-20s | %-4u | %s\r\n", id, lm.fileName, lm.lineNumber,
                                                                lm.fmtString);
    }
}

/**
 * Simple program to decompress log files produced by the NanoLog System.
 * Note that this executable must be compiled with the same BufferStuffer.h
 * as the LogCompressor that generated the compressedLog for this to work.
 */
int main(int argc, char** argv) {
    uint32_t bufferSize = 1<<26;

    if (argc < 2) {
        printf("Decompresses log files produced by the NanoLog System\r\n"
                "into a human readable format.\r\n\r\n");
        printf("\tUsage: %s <logFile> [# messages to print]", argv[0]);
        exit(1);
    }

    char *scratchBufferSpace = static_cast<char*>(calloc(1, bufferSize));
    if (!scratchBufferSpace) {
        printf("Malloc of a %d byte array as a staging buffer "
                "for decompressing failed\r\n", bufferSize);
        exit(-1);
    }

    int msgsToPrint = 0;
    if (argc > 2) {
        try {
            msgsToPrint = std::stoi(argv[2]);
        } catch (const std::invalid_argument& e) {
            printf("Invalid # of message to print, please enter a number:"
                    " %s\r\n",  argv[2]);
            exit(-1);
        } catch (const std::out_of_range& e) {
            printf("# of messages to print is too large: %s\r\n", argv[2]);
            printf("If you intend to print all message, "
                    "exclude the # messages to print parameter.\r\n");
            exit(-1);
        }

        if (msgsToPrint < 0) {
            printf("# of messages to print must be positive: %s\r\n", argv[2]);
            exit(-1);
        }
    }

    decompressLogsTo(argv[1], stdout, msgsToPrint);

    return 0;
}

