/* Copyright (c) 2016-2017 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <cstdlib>
#include <fstream>
#include <vector>

#include <string.h>
#include <stdarg.h>

#include "BufferUtils.h"
#include "Cycles.h"

// File generated by the NanoLog preprocessor that contains all the
// compression and decompression functions.
#include "BufferStuffer.h"

using namespace BufferUtils;

#ifdef DEBUG_DECOMPRESSOR
#define DEBUG_PRINT(...) printf("DEBUG: " __VA_ARGS__)
#else
#define DEBUG_PRINT(...)
#endif

/**
 * Stores a fragment of the compressed log corresponding to a contiguous chunk
 * of log messages belonging to one StagingBuffer.
 */
struct BufferFragment {
    // Stores the bytes in the compressed log fragment. The size is chosen to
    // be 2x the size of a runtime StagingBuffer to account for any other
    // entries that may be inserted at runtime.
    //TODO(syang0) get the variables out please...
    char storage[1<<26];

    // Number of valid bytes in storage
    uint64_t validBytes;

    // The runtime StagingBuffer id associated with this fragment.
    uint32_t runtimeId;

    // For efficient IO, we read the entire fragment in once and then keep
    // track of a read position within the buffer
    const char *readPos;

    // End of the valid data in storage
    char *endOfBuffer;

    // For sorting, store the metadata for the next log message to be
    // decompressed so we can access its timestamp.
    DecompressedMetadata nextLogMetadata;

    /**
     * Read in the next buffer fragment from the compressed log.
     *
     * \param fd
     *      File stream to read it from
     * \param[out] wrapAround
     *      Indicates whether a wrap around was indicated in the log or not.
     *
     * \return
     *      indicates whether the operation succeeded (true) or failed due to
     *      a malformed log data.
     */
    bool readBufferFragment(FILE *fd, bool *wrapAround=NULL) {
        validBytes = fread(storage, 1, BufferChange::maxSize(), fd);
        BufferChange *bc = reinterpret_cast<BufferChange*>(storage);

        if (bc->entryType != EntryType::BUFFER_CHANGE ||
                validBytes < sizeof(BufferChange))
            return false;

        uint64_t remaining = bc->minDistanceToNextBufferChange - validBytes;
        validBytes += fread(storage + validBytes, 1, remaining, fd);

        if (validBytes != bc->minDistanceToNextBufferChange)
            return false;

        readPos = storage;
        endOfBuffer = storage + validBytes;
        runtimeId = decodeBufferChange(&readPos, wrapAround);

        #ifdef DEBUG_DECOMPRESSOR
        DEBUG_PRINT("Found buffer change at %ld to %d with wrapAround=%d and "
                "next being %u bytes away.\r\n", (long)(ftell(fd)),
                runtimeId, *wrapAround, validBytes);
        #endif

        nextLogMetadata = decompressMetadata(&readPos, 0);
        return true;
    }

    inline bool
    decompressNextLogStatement(FILE *outputFd,
                                uint64_t &linesPrinted,
                                uint64_t &lastTimestamp,
                                double cyclesPerSecond)
    {
        if (readPos > endOfBuffer)
            return false;

        double timeDiff;
        if (nextLogMetadata.timestamp >= lastTimestamp)
            timeDiff = 1.0e9*PerfUtils::Cycles::toSeconds(
                                    nextLogMetadata.timestamp - lastTimestamp,
                                    cyclesPerSecond);
        else
            timeDiff = -1.0e9*PerfUtils::Cycles::toSeconds(
                                    lastTimestamp - nextLogMetadata.timestamp,
                                    cyclesPerSecond);
        if (linesPrinted == 0)
            timeDiff = 0;

        if (outputFd)
            fprintf(outputFd, "%4ld) +%12.2lf ns: ", linesPrinted, timeDiff);

        GeneratedFunctions::decompressAndPrintFnArray[nextLogMetadata.fmtId](
                                                    &readPos, outputFd, NULL);

        lastTimestamp = nextLogMetadata.timestamp;
        linesPrinted++;
        if (readPos > endOfBuffer)
            return false;

        nextLogMetadata = decompressMetadata(&readPos, nextLogMetadata.timestamp);

        return true;
    }
};

/**
 * Given a compressed NanoLog log file, decompress it and output it to an
 * outputFd.
 *
 * \param filename
 *      Compressed NanoLog log file to decompress
 * \param outputFd
 *      File Descriptor to fprintf the original log messages to
 * \param[optional] msgsToPrint
 *      Limit for how many log messages to print
 *
 * \return
 *      number of log encountered
 */
long
decompressLogsTo(const char *filename, FILE *outputFd, uint64_t msgsToPrint = 0)
{
    double cyclesPerSecond = PerfUtils::Cycles::getCyclesPerSec();
    Checkpoint cp;
    uint64_t linesPrinted = 0;
    uint64_t lastTimestamp = 0;

    FILE *in = fopen(filename, "rb");
    if (!in) {
        printf("Unable to open file: %s\r\n", filename);
        exit(-1);
    }

    if (outputFd)
        fprintf(outputFd, "# Opening file %s\r\n", filename);

    if(!readCheckpoint(cp, in)) {
        printf("Error: Could not read initial checkpoint, "
                "the compressed log may be corrupted.\r\n");
        exit(-1);
    }
    cyclesPerSecond = cp.cyclesPerSecond;

    BufferFragment *bf = new BufferFragment();
    while(!feof(in) && linesPrinted < msgsToPrint) {
        bool wrapAround = false;
        if (!bf->readBufferFragment(in, &wrapAround))
            break;

        bool success = false;
        do {
            success = bf->decompressNextLogStatement(outputFd,
                                                        linesPrinted,
                                                        lastTimestamp,
                                                        cyclesPerSecond);
        } while (success);
    }

    if (outputFd)
        fprintf(outputFd, "\r\n\r\nDecompression Complete after printing %lu "
            "log messages\r\n", linesPrinted);

    return linesPrinted;
}

/**
 * Find all the original NANO_LOG format strings in the user sources that
 * statically contain the searchString and print them out in the format
 * "id   | filename | line | format string"
 *
 * \param searchString
 *      Static string to search for in the format strings
 */
void
printLogMetadataContainingSubstring(std::string searchString)
{
    std::vector<size_t> matchingLogIds;

    for (size_t i = 0; i < GeneratedFunctions::numLogIds; ++i) {
        const char *fmtMsg = GeneratedFunctions::logId2Metadata[i].fmtString;
        if (strstr(fmtMsg, searchString.c_str()))
            matchingLogIds.push_back(i);
    }

    printf("%4s | %-20s | %-4s | %s\r\n", "id", "filename", "line",
                                                            "format string");
    for (auto id : matchingLogIds) {
        GeneratedFunctions::LogMetadata lm = GeneratedFunctions::logId2Metadata[id];
        printf("%4lu | %-20s | %-4u | %s\r\n", id, lm.fileName, lm.lineNumber,
                                                                lm.fmtString);
    }
}

/**
 * Simple program to decompress log files produced by the NanoLog System.
 * Note that this executable must be compiled with the same BufferStuffer.h
 * as the LogCompressor that generated the compressedLog for this to work.
 */
int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Decompresses log files produced by the NanoLog System\r\n"
                "into a human readable format.\r\n\r\n");
        printf("\tUsage: %s <logFile> [# messages to print]", argv[0]);
        exit(1);
    }

    int msgsToPrint = 0;
    if (argc > 2) {
        try {
            msgsToPrint = std::stoi(argv[2]);
        } catch (const std::invalid_argument& e) {
            printf("Invalid # of message to print, please enter a number:"
                    " %s\r\n",  argv[2]);
            exit(-1);
        } catch (const std::out_of_range& e) {
            printf("# of messages to print is too large: %s\r\n", argv[2]);
            printf("If you intend to print all message, "
                    "exclude the # messages to print parameter.\r\n");
            exit(-1);
        }

        if (msgsToPrint < 0) {
            printf("# of messages to print must be positive: %s\r\n", argv[2]);
            exit(-1);
        }
    }

    if (msgsToPrint == 0)
        msgsToPrint = -1;

    decompressLogsTo(argv[1], stdout, msgsToPrint);

    return 0;
}

