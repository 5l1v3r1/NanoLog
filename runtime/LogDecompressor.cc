/* Copyright (c) 2016 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <cstdlib>
#include <fstream>

#include "BufferUtils.h"
#include "Cycles.h"

// File generated by the NanoLog preprocessor that contains all the
// compression and decompression functions.
#include "BufferStuffer.h"

using namespace BufferUtils;

#ifdef DEBUG_DECOMPRESSOR
#define DEBUG_PRINT(x) printf("DEBUG: " x)
#else
#define DEBUG_PRINT(x)
#endif

/**
 * Simple program to decompress log files produced by the NanoLog System.
 * Note that this executable must be compiled with the same BufferStuffer.h
 * as the LogCompressor that generated the compressedLog for this to work.
 */
int main(int argc, char** argv) {
    uint32_t bufferSize = 1<<26;

    if (argc < 2) {
        printf("Decompresses log files produced by the NanoLog System\r\n"
                "into a human readable format.\r\n\r\n");
        printf("\tUsage: %s <logFile> [# messages to print]", argv[0]);
        exit(1);
    }

    char *scratchBufferSpace = static_cast<char*>(calloc(1, bufferSize));
    if (!scratchBufferSpace) {
        printf("Malloc of a %d byte array as a staging buffer "
                "for decompressing failed\r\n", bufferSize);
        exit(-1);
    }

    int msgsToPrint = 0;
    if (argc > 2) {
        try {
            msgsToPrint = std::stoi(argv[2]);
        } catch (const std::invalid_argument& e) {
            printf("Invalid # of message to print, please enter a number:"
                    " %s\r\n",  argv[2]);
            exit(-1);
        } catch (const std::out_of_range& e) {
            printf("# of messages to print is too large: %s\r\n", argv[2]);
            printf("If you intend to print all message, "
                    "exclude the # messages to print parameter.\r\n");
            exit(-1);
        }

        if (msgsToPrint < 0) {
            printf("# of messages to print must be positive: %s\r\n", argv[2]);
            exit(-1);
        }
    }

    std::ifstream in(argv[1], std::ifstream::binary);
    if (!in.is_open()) {
        printf("Unable to open file: %s\r\n", argv[1]);
        exit(-1);
    }

    printf("Opening file %s\r\n", argv[1]);

    Checkpoint cp;
    double cyclesPerSecond = PerfUtils::Cycles::getCyclesPerSec();
    int linesPrinted = 0;
    bool bufferChanged = false;
    uint64_t lastTimestamp = 0;
    while (!in.eof()) {
        if (msgsToPrint > 0 && linesPrinted >= msgsToPrint)
            break;

        EntryType nextType = BufferUtils::peekEntryType(in);

        if (nextType == EntryType::LOG_MSG) {
            DecompressedMetadata dm =
                BufferUtils::decompressMetadata(in,
                                        (bufferChanged) ? 0 : lastTimestamp);
            bufferChanged = false;
            double timeDiff;
            if (dm.timestamp >= lastTimestamp)
                timeDiff = 1.0e9*PerfUtils::Cycles::toSeconds(
                                                dm.timestamp - lastTimestamp,
                                                cyclesPerSecond);
            else
                timeDiff = -1.0e9*PerfUtils::Cycles::toSeconds(
                                                lastTimestamp - dm.timestamp,
                                                cyclesPerSecond);
            if (linesPrinted == 0)
                timeDiff = 0;
            
            printf("%4d) +%12.2lf ns: ", linesPrinted, timeDiff);
            decompressAndPrintFnArray[dm.fmtId](in, stdout);

            lastTimestamp = dm.timestamp;
            ++linesPrinted;
        } else if (nextType == EntryType::CHECKPOINT) {
            cp = BufferUtils::readCheckpoint(in);
            cyclesPerSecond = cp.cyclesPerSecond;
            DEBUG_PRINT("DEBUG: Found Checkpoint\r\n");
        } else if (nextType == EntryType::INVALID) {
            // Consume pad bytes
            while(in.peek() == 0 && in.good())
                in.get();

            if (in.eof())
                break;
        } else {
            BufferUtils::decodeBufferChange(in);
            bufferChanged = true;
            DEBUG_PRINT("Found buffer change\r\n");
        }
    }

    printf("\r\n\r\nDecompression Complete after printing %d log messages\r\n",
            linesPrinted);

    return 0;
}

