/* Copyright (c) 2016 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef FASTLOGGER_H
#define FASTLOGGER_H

#include <condition_variable>
#include <mutex>
#include <thread>
#include <vector>

#include <aio.h>
#include <assert.h>
#include <fcntl.h>

#include "Common.h"

// These header files are needed for the in-lined runtime code. They are
// included here so that the user of the FastLogger system only has to
// include one file.
#include <string.h>         /* strlen + memcpy */

#include "Cycles.h"         /* Cycles::rdtsc() */
#include "BufferUtils.h"

namespace PerfUtils {

/**
 * FastLogger provides runtime support to the C++ code generated by the
 * Preprocessor component and serves as the main interface for the user.
 * Its main responsibilities are to manage fast thread-local storage to stage
 * uncompressed log messages and manage a background thread to compress the
 * log messages to an output file.
 */
class FastLogger {
public:
    //TODO(syang0) Where should I put these? These technically aren't
    // supposed to for the user to toggle...

    // Toggles whether the compressed log file will be output via POSIX AIO
    // or via regular blocking file writes (for debugging)
    static const bool USE_AIO = true;

    // Controls in what mode the file will be opened
    static const int FILE_PARAMS = O_APPEND|O_RDWR|O_CREAT|O_NOATIME|
                                                            O_DSYNC|O_DIRECT;

    // Determines the byte size of the staging buffer. It is fairly large
    // to ensure that in the best case scenario of 8x compression, we will
    // end up with ~8MB of data which is optimal for amortizing disk seeks.
    static const uint32_t STAGING_BUFFER_SIZE = 1<<26;

    // Determines the size of the output buffer used to store compressed log
    // messages. It should be at least 8MB large to amortize disk seeks.
    static const uint32_t OUTPUT_BUFFER_SIZE = 1<<24;


    // User API
    static void printStats();
    static void preallocate();
    static void setLogFile(const char* filename);
    static void sync();


    /// Internal API after this point
    /**
     * Allocate thread-local space for the generated C++ code to store an
     * uncompressed log message, but do not make it available for compression
     * yet. The caller should invoke finishAlloc() to make the space visible
     * to the compression thread and this function shall not be invoked
     * again until the corresponding finishAlloc() is invoked first.
     *
     * Note this will block of the buffer is full.
     *
     * \param nbytes
     *      number of bytes to allocate in the
     *
     * \return
     *      pointer to the allocated space
     */
    static inline char*
    __internal_reserveAlloc(size_t nbytes)
    {
        if (stagingBuffer == nullptr)
            fastLogger.ensureStagingBufferAllocated();
        
        return stagingBuffer->reserveProducerSpace(nbytes);
    }

    /**
     * Complement to reserveAlloc, makes the bytes previously reserveAlloc()-ed
     * visible to the compression/output thread.
     *
     * \param nbytes
     *      Number of bytes to make visible
     */
    static inline void
    __internal_finishAlloc(size_t nbytes){
        stagingBuffer->finishReservation(nbytes);
    }

    // This class is intended to be instantiated as a C++ thread_local to
    // synchronize the destruction of the thread local stagingBuffer with
    // thread death.
    //
    // The reason why this class exists rather than wrapping the stagingBuffer
    // in a unique_ptr or declaring the stagingBuffer itself to be thread_local
    // is because of performance. Dereferencing the former costs 10 ns and the
    // latter allocates large amounts of resources for every thread that is
    // created; even ones which don't use the FastLogger system (wasteful).
    class StagingBufferDestroyer {
    public:
        // TODO(syang0) I wonder if it'll be better if stagingBuffer was
        // actually a thread_local wrapper with dereference operators
        // implemented.

        explicit StagingBufferDestroyer() {
        }

        // Weird C++ hack; C++ thread_local are instantiated upon first use
        // thus the StagingBuffer has to invoke this function in order
        // to instantiate this object.
        void stagingBufferCreated() { }

        virtual ~StagingBufferDestroyer() {
            if (stagingBuffer != nullptr) {
                delete stagingBuffer;
                stagingBuffer = NULL;
            }
        }
    };

PRIVATE:
    //Forward Declaration
    class StagingBuffer;

    FastLogger();
    ~FastLogger();

    // Storage for staging uncompressed log statements for compression
    static __thread StagingBuffer* stagingBuffer;

    // Destroys the __thread StagingBuffer upon its own destruction, which
    // is synchronized with thread death
    static thread_local StagingBufferDestroyer sbc;

    // Singleton FastLogger that manages the thread-local structures and
    // background output thread.
    static FastLogger fastLogger;

    void compressionThreadMain();
    void printStatsInternal();
    void setLogFile_internal(const char* filename);
    void waitForAIO();

    void deallocateStagingBuffer(StagingBuffer *sb);

    /**
     * Allocates thread-local structures if they weren't already allocated.
     * This is used by the generated C++ code to ensure it has space to
     * log uncompressed messages to and by the user if they wish to
     * preallocate the datastructures on thread creation.
     */
    inline void
    ensureStagingBufferAllocated()
    {
        std::lock_guard<std::mutex> guard(bufferMutex);

        if (stagingBuffer == nullptr) {
            stagingBuffer = new StagingBuffer();
            threadBuffers.push_back(stagingBuffer);
        }
    }

    // Tracks the thread-local stagingBuffers globally; A nullptr entry
    // indicates that the owning thread has been destructed
    std::vector<StagingBuffer*> threadBuffers;

    // Protects reads and writes to threadBuffers
    std::mutex bufferMutex;

    // Background thread that polls the various staging buffers, compresses
    // the staged log messages, and outputs it to a file.
    std::thread compressionThread;

    // Indicates there's an operation in aioCb that should be waited on
    bool hasOutstandingOperation;

    // Flag signaling the compressionThread to stop running
    bool compressionThreadShouldExit;

    // Indicates that a sync request has been made but is not completed
    // by the background thread yet.
    bool syncRequested;

    // Protects the condition variables below
    std::mutex condMutex;

    // Signal for when the compression thread should wakeup
    std::condition_variable workAdded;

    // Signaled when the LogCompressor makes a complete pass through all the
    // thread staging buffers and finds no log messages to output.
    std::condition_variable hintQueueEmptied;

    // File handle for the output file; should only be opened once at the
    // construction of the LogCompressor
    int outputFd;

    // POSIX AIO structure used to communicate async IO requests
    struct aiocb aioCb;

    // Used to stage the compressed log messages before passing it on to the
    // POSIX AIO library.

    // Dynamically allocated buffer to stage compressed log message before
    // handing it over to the POSIX AIO library for output.
    char *compressingBuffer;

    // Dynamically allocated double buffer that is swapped with the
    // compressingBuffer when the latter is passed to the POSIX AIO library.
    char *outputDoubleBuffer;

    // Metric: Amount of time spent compressing the dynamic log data
    uint64_t cyclesCompressing;

    // Metric: Amount of time spent scanning the buffers for work and
    // compressing events found.
    uint64_t cyclesScanningAndCompressing;

    // Metric: Amount of time spent on fsync() and writes. Note that if posix
    // AIO is used, the only the amount of time it takes to submit the job is
    // recorded.
    uint64_t cyclesAioAndFsync;

    // Metric: Number of bytes read in from the staging buffers
    uint64_t totalBytesRead;

    // Metric: Number of bytes written to the output file (includes padding)
    uint64_t totalBytesWritten;

    // Metric: Number of pad bytes written to round the file to the nearest 512B
    uint64_t padBytesWritten;

    // Metric: Number of events compressed and outputted.
    uint64_t eventsProcessed;

    // Metric: Number of times an AIO write was completed.
    uint32_t numAioWritesCompleted;

    /**
     * Implements a circular FIFO producer/consumer byte queue that is used
     * to hold the dynamic information of a FastLogger log statement (producer)
     * as it waits for compression via the FastLogger background thread
     * (consumer). There exists a StagingBuffer for every thread that uses
     * the FastLogger system.
     */
    class StagingBuffer {
    public:
        /**
         * Attempt to reserve contiguous space for the producer without
         * making it visible to the consumer. The user should invoke
         * finishReservation() to make this entry visible to the consumer
         * and shall not invoke this function again until they have
         * finishAlloc-ed(). This mechanism is in place to allow the producer
         * to fully initialize the data contents before exposing it to the
         * consumer.
         *
         * This function will block behind the consumer if there's not
         * enough space.
         *
         * \param nbytes
         *      Number of bytes to allocate
         *
         * \return
         *      Pointer to at least nbytes of contiguous space
         */
        inline char*
        reserveProducerSpace(size_t nbytes) {
            // Fast in-line path
            if (nbytes < minFreeSpace)
                return producerPos;

            // Slow allocation
            return reserveSpaceInternal(nbytes);
        }

        /**
         * Complement to reserveProducerSpace that makes nbytes starting from
         * the return of reserveProducerSpace visible to the consumer.
         */
        inline void
        finishReservation(size_t nbytes) {
            assert(nbytes < minFreeSpace);
            assert(producerPos + nbytes < storage + STAGING_BUFFER_SIZE);
            // Don't pass the read head with finish
            assert(producerPos >= consumerPos
                            || producerPos + nbytes < consumerPos);

            minFreeSpace -= nbytes;
            producerPos += nbytes;
        }

        char* peek(uint64_t *bytesAvailable);

        /**
         * Consumes the next RecordEntry and advances the internal pointers
         * for peek().
         */
        inline void
        consume(uint64_t nbytes) {
            consumerPos += nbytes;
        }

        StagingBuffer()
            : producerPos(storage)
            , endOfRecordedSpace(storage + STAGING_BUFFER_SIZE)
            , minFreeSpace(STAGING_BUFFER_SIZE)
            , cacheLineSpacer()
            , consumerPos(storage)
            , storage()
        {
            // Empty function, but causes the C++ runtime to instantiate the
            // sbc thread_local (see documentation in function).
            sbc.stagingBufferCreated();
        }

        ~StagingBuffer() {
            fflush(stdout);

            // Flush out all log messages
            uint64_t remainingData;
            peek(&remainingData);
            
            while (remainingData > 0) {
                FastLogger::sync();
                peek(&remainingData);
            }

            fastLogger.deallocateStagingBuffer(this);
        }

    PRIVATE:
        char* reserveSpaceInternal(size_t nbytes, bool blocking=true);

        // Position within storage[] where the producer may place new data
        char *producerPos;

        // Marks the end of valid data for the consumer. Set by the producer
        // on a roll-over
        char *endOfRecordedSpace;

        // Lower bound on the number of bytes the producer can allocate
        // without rolling over the producerPos or stalling behind the consumer
        uint64_t minFreeSpace;

        // An extra cache-line to separate the variables that are primarily
        // updated/read by the producer (above) from the ones by the
        // consumer(below)
        char cacheLineSpacer[PerfUtils::Util::BYTES_PER_CACHE_LINE];

        // Position within the storage buffer where the consumer will consume
        // the next bytes from. This value is only updated by the consumer.
        char *consumerPos;

        // Backing store used to implement the circular queue
        char storage[STAGING_BUFFER_SIZE];
    };

    friend StagingBuffer;

};  // FastLogger
}; // namespace PerfUtils

#endif /* FASTLOGGER_H */

