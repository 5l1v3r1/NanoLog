/* Copyright (c) 2016 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef FASTLOGGER_H
#define FASTLOGGER_H

#include <condition_variable>
#include <mutex>
#include <thread>
#include <vector>

#include <aio.h>
#include <assert.h>
#include <fcntl.h>

#include "Common.h"

// These header files are needed for the in-lined runtime code. They are
// included here so that the user of the FastLogger system only has to
// include one file.
#include <string.h>         /* strlen + memcpy */

#include "Cycles.h"         /* Cycles::rdtsc() */
#include "BufferUtils.h"

namespace PerfUtils {

/**
 * FastLogger provides runtime support to the C++ code generated by the
 * Preprocessor component and serves as the main interface for the user.
 * Its main responsibilities are to manage fast thread-local storage to stage
 * uncompressed log messages and manage a background thread to compress the
 * log messages to an output file.
 */
class FastLogger {
public:
    //TODO(syang0) Where should I put these? These technically aren't
    // supposed to for the user to toggle...

    // Toggles whether the compressed log file will be outputted via POSIX AIO
    // or via regular blocking file writes (for debugging)
    static const bool USE_AIO = true;

    // Controls in what mode the file will be opened in
    static const int FILE_PARAMS = O_APPEND|O_RDWR|O_CREAT|O_NOATIME|
                                                            O_DSYNC|O_DIRECT;

    // Determines the byte size of the staging buffer. It is fairly large
    // to ensure that in the best case scenario of 8x compression, we will
    // end up with ~8MB of data which is optimal for amortizing disk seeks.
    static const uint32_t STAGING_BUFFER_SIZE = 1<<26;

    // Determines the size of the output buffer used to store compressed log
    // messages. It should be at least 8MB large to amortize disk seeks.
    static const uint32_t OUTPUT_BUFFER_SIZE = 1<<24;


    // User API
    static void printStats();
    static void preallocate();
    static void sync();


    /// Internal API after this point
    /**
     * Allocate thread-local space for the generated C++ code to store an
     * uncompressed log message, but do not make it available for compression
     * yet. The caller should invoke finishAlloc() to make the space visible
     * to the compression thread and this function shall not be invoked
     * again until the corresponding finishAlloc() is invoked first.
     *
     * Note this will block of the buffer is full.
     *
     * \param nbytes
     *      number of bytes to allocate in the
     *
     * \return
     *      pointer to the allocated space
     */
    static inline char*
    __internal_reserveAlloc(size_t nbytes)
    {
        if (stagingBuffer == nullptr)
            fastLogger.ensureStagingBufferAllocated();
        
        return stagingBuffer->reserveProducerSpace(nbytes);
    }

    /**
     * Complement to reserveAlloc, makes the bytes previously reserveAlloc()-ed
     * visible to the compression/output thread.
     *
     * \param nbytes
     *      Number of bytes to make visible
     */
    static inline void
    __internal_finishAlloc(size_t nbytes){
        stagingBuffer->finishReservation(nbytes);
    }

PRIVATE:
    //Forward Declaration
    class StagingBuffer;

    FastLogger();
    ~FastLogger();

    // Storage for staging uncompressed log statements for compression
    static __thread StagingBuffer* stagingBuffer;

    // Singleton FastLogger that manages the thread-local structures and
    // background output thread.
    static FastLogger fastLogger;

    void compressionThreadMain();
    void waitForAIO();
    void printStatsInternal();

    void deallocateStagingBuffer(StagingBuffer *sb);

    /**
     * Allocates thread-local structures if they weren't already allocated.
     * This is used by the generated C++ code to ensure it has space to
     * log uncompressed messages to and by the user if they wish to
     * preallocate the datastructures on thread creation.
     */
    inline void
    ensureStagingBufferAllocated()
    {
        std::lock_guard<std::mutex> guard(bufferMutex);

        if (stagingBuffer == nullptr) {
            stagingBuffer = new StagingBuffer();
            threadBuffers.push_back(stagingBuffer);
        }
    }

    // Tracks the thread-local stagingBuffers globally; A nullptr entry
    // indicates that the owning thread has been destructed
    std::vector<StagingBuffer*> threadBuffers;

    // Protects reads and writes to threadBuffers
    std::mutex bufferMutex;

    // Background thread that polls the various staging buffers, compresses
    // the staged log messages, and outputs it to a file.
    std::thread compressionThread;

    // Indicates there's an operation in aioCb that should be waited on
    bool hasOutstandingOperation;

    // Flag signaling the compressionThread to stop running
    bool compressionThreadShouldExit;

    // Level trigger for the background thread to make a complete pass through
    // all the staging buffers before sleeping.
    bool syncRequested;

    // Protects the condition variables below
    std::mutex condMutex;

    // Signal for when the compression thread should wakeup
    std::condition_variable workAdded;

    // Signaled when the LogCompressor makes a complete pass through all the
    // thread staging buffers and finds no log messages to output.
    std::condition_variable hintQueueEmptied;

    // File handle for the output file; should only be opened once at the
    // construction of the LogCompressor
    int outputFd;

    // POSIX AIO structure used to communicate async IO requests
    struct aiocb aioCb;

    // Used to stage the compressed log messages before passing it on to the
    // POSIX AIO library.
    char *outputBuffer;

    // Double buffer for outputBuffer that is used to hold compressed log
    // messages while POSIX AIO outputs it to a file.
    char *posixBuffer;

    // Metric: Amount of time spent compressing the dynamic log data
    uint64_t cyclesCompressing;

    // Metric: Amount of time spent scanning the buffers for work and
    // compressing events found.
    uint64_t cyclesScanningAndCompressing;

    // Metric: Amount of time spent on fsync() and writes. Note that if posix
    // AIO is used, the only the amount of time it takes to submit the job is
    // recorded.
    uint64_t cyclesAioAndFsync;

    // Metric: Number of bytes read in from the staging buffers
    uint64_t totalBytesRead;

    // Metric: Number of bytes written to the output file (includes padding)
    uint64_t totalBytesWritten;

    // Metric: Number of pad bytes written to round the file to the nearest 512B
    uint64_t padBytesWritten;

    // Metric: Number of events compressed and outputted.
    uint64_t eventsProcessed;

    // Metric: Number of times an AIO write was completed.
    uint32_t numAioWritesCompleted;

        /**
     * Implements a circular FIFO producer/consumer byte queue that is used
     * to hold the dynamic information of a FastLogger log statement (producer)
     * as it waits for compression via the FastLogger background thread
     * (consumer)
     */
    class StagingBuffer {
    public:
        /**
         * Attempt to reserve contiguous space for the producer without
         * making it visible to the consumer. The user should invoke
         * finishReservation() to make this entry visible to the consumer
         * and shall not invoke this function again until they have
         * finishAlloc-ed().
         *
         * This function will block behind the consumer if there's
         * not enough space.
         *
         * \param nbytes
         *      Number of bytes to allocate
         *
         * \return
         *      Pointer to at least nbytes of contiguous space
         */
        inline char*
        reserveProducerSpace(size_t nbytes) {
            // Fast in-line path
            if (nbytes < minFreeSpace)
                return producerPos;

            // Slow allocation
            return reserveSpaceInternal(nbytes);
        }

        /**
         * Complement to reserveProducerSpace that makes nbytes from the
         * producer space visible to the consumer.
         */
        inline void
        finishReservation(size_t nbytes) {
            assert(nbytes < minFreeSpace);
            assert(producerPos + nbytes < storage + STAGING_BUFFER_SIZE);
            // Don't pass the read head with finish
            assert(producerPos >= consumerPos
                            || producerPos + nbytes < consumerPos);

            minFreeSpace -= nbytes;
            producerPos += nbytes;
        }

        char* peek(uint64_t *bytesAvailable);

        /**
         * Consumes the next RecordEntry and advances the internal pointers
         * for peek().
         */
        inline void
        consume(uint64_t nbytes) {
            consumerPos += nbytes;
        }

        StagingBuffer()
            : producerPos(storage)
            , endOfRecordedSpace(storage + STAGING_BUFFER_SIZE)
            , minFreeSpace(STAGING_BUFFER_SIZE)
            , cacheLineSpacer()
            , consumerPos(storage)
            , storage()
        {
//            printf("Staging Buffer Created!\r\n");
        }

        ~StagingBuffer() {
            //TODO(syang0) This isn't actually run when a thread dies!!!!
//            printf("Staging Buffer Destructed!\r\n");

            // Flush out all log messages
            uint64_t remainingData;
            peek(&remainingData);
            
            while (remainingData > 0) {
                FastLogger::sync();
                peek(&remainingData);
            }

            fastLogger.deallocateStagingBuffer(this);
        }

    //TODO(syang0) PRIVATE
    PRIVATE:
        char* reserveSpaceInternal(size_t nbytes, bool blocking=true);

        // Position within storage[] where the producer may place new data
        char *producerPos;

        // Marks the end of valid data for the consumer. Set by the producer
        // on a roll-over
        char *endOfRecordedSpace;

        // Lower bound on the number of bytes the producer can allocate
        // without rolling over the producerPos or stalling behind the consumer
        uint64_t minFreeSpace;

        // An extra cache-line to separate the variables that are primarily
        // updated/read by the producer (above) from the ones by the
        // consumer(below)
        static const uint32_t BYTES_PER_CACHE_LINE = 64;
        char cacheLineSpacer[BYTES_PER_CACHE_LINE];

        // Position within the storage buffer where the consumer can start
        // consuming bytes from. This value is only updated by the consumer.
        char *consumerPos;

        // Backing store used to implement the circular queue
        char storage[STAGING_BUFFER_SIZE];
    };

    friend StagingBuffer;

};  // FastLogger
}; // namespace PerfUtils

#endif /* FASTLOGGER_H */

